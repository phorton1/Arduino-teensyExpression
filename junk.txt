

#if 0		// Pauls parser

	// ok, so the question is how much of this do I keep
	// or re-implementl, or should I switch back to Paul's code?
	
	// Right now, at a uint32_t per message I'm pretty fast,
	// but the USB's could be hooked up even tighter as the
	// endpoint packet sizes allowed ... to echo whole buffers
	// from the hosted device to the device-device.
	
	// In practice, I am guessing that I rarely get a packet
	// that contains two distinct events (i.e. note-on) though
	// it could happen like when strumming.
	
	// I need to try to get it as fast as possible to *maybe* act
	// as the host for the FTP, but there is no good way to measure
	// it versus plugging directly into the iPad ...
	
	// hmm .. a recording app on the iPad could record the guitar
	// signal and compare it to the sound generated by the synth.
	
	

	
	bool MIDIDevice::read(uint8_t channel)
	{
		uint32_t n, head, tail, avail, ch, type1, type2, b1;
	
		head = rx_head;
		tail = rx_tail;
		if (head == tail) return false;
		if (++tail >= RX_QUEUE_SIZE) tail = 0;
		n = rx_queue[tail];
		rx_tail = tail;
		if (!rx_packet_queued && rxpipe) {
				avail = (head < tail) ? tail - head - 1 : RX_QUEUE_SIZE - 1 - head + tail;
			if (avail >= (uint32_t)(rx_size>>2)) {
				__disable_irq();
				queue_Data_Transfer(rxpipe, rx_buffer, rx_size, this);
				__enable_irq();
			}
		}
		println("read: ", n, HEX);
		
		// 0x3C1FB70B    =   B7 1F  3C    
	
		type1 = n & 15;					// 0x0B = low order nibble of MSB = the midi "message_type"
		type2 = (n >> 12) & 15;         // 0x0B = high order nibble of 2nd MSB = the midi message "command"
		b1 = (n >> 8) & 0xFF;           // 0xB7 = the full midi message command (with channel)
		ch = (b1 & 15) + 1;             // 8 == the one based channel number
		
		msg_cable = (n >> 4) & 15;      // 0x00 = high order nibble of MSB = midi "cable" number
			// we receive cables 0 and 1 from the FTP
			// midiOx only accepts on cable 0 (i.e I am not using teensy USB mode MIDI4, etc)
			
		// midi commands 0x8 thru 0xE (0x8n thru 0xEn) have a channel built in to the 0th byte
		// and are not realtime or "common"
		
		
		if (type1 >= 0x08 && type1 <= 0x0E)		// NON-REALTIME CHANNEL MESSAGES
		{
			if (channel && channel != ch)
			{
				// ignore other channels when user wants single channel read
				return false;
			}
			
			// I wonder why he assiduously checks both numbers
			// Do devices often not send correct midi messages
			// where they disagree?
			
			if (type1 == 0x08 && type2 == 0x08)
			{
				msg_type = 0x80;		// 0x80 = Note off
				if (handleNoteOff) {
					(*handleNoteOff)(ch, (n >> 16), (n >> 24));
				}
			}
			else if (type1 == 0x09 && type2 == 0x09)
			{
				if ((n >> 24) > 0)
				{
					msg_type = 0x90;	// 0x90 = Note on
					if (handleNoteOn)
					{
						(*handleNoteOn)(ch, (n >> 16), (n >> 24));
					}
				}
				else
				{
					msg_type = 0x80;	// 0x80 = Note off
					if (handleNoteOff)
					{
						(*handleNoteOff)(ch, (n >> 16), (n >> 24));
					}
				}
			} else	if (type1 == 0x0A && type2 == 0x0A)
			{
				msg_type = 0xA0;		// 0xA0 = AfterTouchPoly
				if (handleVelocityChange)
				{
					(*handleVelocityChange)(ch, (n >> 16), (n >> 24));
				}
			}
			else if (type1 == 0x0B && type2 == 0x0B)
			{
				msg_type = 0xB0;		// 0xB0 = Control Change
				if (handleControlChange)
				{
					(*handleControlChange)(ch, (n >> 16), (n >> 24));
				}
			}
			else if (type1 == 0x0C && type2 == 0x0C)
			{
				msg_type = 0xC0;		// 0xC0 = Program Change
				if (handleProgramChange)
				{
					(*handleProgramChange)(ch, (n >> 16));
				}
			}
			else if (type1 == 0x0D && type2 == 0x0D)
			{
				msg_type = 0xD0;		// 0xD0 = After Touch
				if (handleAfterTouch)
				{
					(*handleAfterTouch)(ch, (n >> 16));
				}
			} else if (type1 == 0x0E && type2 == 0x0E)
			{
				msg_type = 0xE0;		// 0xE0 = Pitch Bend
				if (handlePitchChange)
				{
					int value = ((n >> 16) & 0x7F) | ((n >> 17) & 0x3F80);
					value -= 8192; // 0 to 16383 --> -8192 to +8191
					(*handlePitchChange)(ch, value);
				}
			}
			else
			{
				return false;
			}
			
		return_message:
		
			msg_channel = ch;
			msg_data1 = (n >> 16);
			msg_data2 = (n >> 24);
			return true;
		
		}	// CHANNEL SPECIFIC MESSAGES
		
		
		// CHANNEL SPECIFIC SYSTEM COMMON OR REALTIME MESSAGES
		
		if (type1 == 0x02 ||
			type1 == 0x03 ||
			(type1 == 0x05 && b1 >= 0xF1 && b1 != 0xF7))
		{
		system_common_or_realtime:
			
			switch (b1)
			{
				case 0xF1: // usbMIDI.TimeCodeQuarterFrame
					if (handleTimeCodeQuarterFrame)
					{
						(*handleTimeCodeQuarterFrame)(n >> 16);
					}
					break;
				case 0xF2: // usbMIDI.SongPosition
					if (handleSongPosition)
					{
						(*handleSongPosition)(((n >> 16) & 0x7F) | ((n >> 17) & 0x3F80));
					}
					break;
				case 0xF3: // usbMIDI.SongSelect
					if (handleSongSelect)
					{
						(*handleSongSelect)(n >> 16);
					}
					break;
				case 0xF6: // usbMIDI.TuneRequest
					if (handleTuneRequest)
					{
						(*handleTuneRequest)();
					}
					break;
				case 0xF8: // usbMIDI.Clock
					if (handleClock)
					{
						(*handleClock)();
					}
					else if (handleRealTimeSystem)
					{
						(*handleRealTimeSystem)(0xF8);
					}
					break;
				case 0xFA: // usbMIDI.Start
					if (handleStart)
					{
						(*handleStart)();
					}
					else if (handleRealTimeSystem)
					{
						(*handleRealTimeSystem)(0xFA);
					}
					break;
				case 0xFB: // usbMIDI.Continue
					if (handleContinue)
					{
						(*handleContinue)();
					}
					else if (handleRealTimeSystem)
					{
						(*handleRealTimeSystem)(0xFB);
					}
					break;
				case 0xFC: // usbMIDI.Stop
					if (handleStop)
					{
						(*handleStop)();
					}
					else if (handleRealTimeSystem)
					{
						(*handleRealTimeSystem)(0xFC);
					}
					break;
				case 0xFE: // usbMIDI.ActiveSensing
					if (handleActiveSensing)
					{
						(*handleActiveSensing)();
					}
					else if (handleRealTimeSystem)
					{
						(*handleRealTimeSystem)(0xFE);
					}
					break;
				case 0xFF: // usbMIDI.SystemReset
					if (handleSystemReset)
					{
						(*handleSystemReset)();
					}
					else if (handleRealTimeSystem)
					{
						(*handleRealTimeSystem)(0xFF);
					}
					break;
				default:
					return false; // unknown message, ignore it
			}
			msg_type = b1;
			goto return_message;
		}
		
		// SYSEX (continue) messge
		
		if (type1 == 0x04) {
			sysex_byte(n >> 8);
			sysex_byte(n >> 16);
			sysex_byte(n >> 24);
			return false;
		}
		
		// SYSEX (end) message
		// where the length is encoded in the type
		
		if (type1 >= 0x05 &&
			type1 <= 0x07)
		{
			sysex_byte(b1);
			
			// allow for buggy devices which use code 5 to transmit 1 byte at a time
			// https://forum.pjrc.com/threads/43450?p=164596&viewfull=1#post164596
			
			if (type1 == 0x05 && b1 != 0xF7) return false;
			if (type1 >= 0x06) sysex_byte(n >> 16);
			if (type1 == 0x07) sysex_byte(n >> 24);
			
			uint16_t len = msg_sysex_len;
			msg_data1 = len;
			msg_data2 = len >> 8;
			msg_sysex_len = 0;
			msg_type = 0xF0;			// 0xF0 = SystemExclusive
			
			if (handleSysExPartial)
			{
				(*handleSysExPartial)(msg_sysex, len, 1);
			}
			else if (handleSysExComplete)
			{
				(*handleSysExComplete)(msg_sysex, len);
			}
			return true;
		}
		
		// SYSEX (start) message,
		// except 0xF8 which is a realtime message ...
		
		if (type1 == 0x0F)
		{
			if (b1 >= 0xF8)
			{
				goto system_common_or_realtime;
			}
			
			// this is the code that allows sysex messages to include
			// subsequent F0's in them, which midiOx doesn't deal with
			
			if (b1 == 0xF0 || msg_sysex_len > 0)
			{
				// Is this really needed?  Mac OS-X does this, but do any devices?
				sysex_byte(b1);
			}
		}
		return false;
	}
	
	
	// weird that it's artificially limited to 290 by SYSEX_MAX_LEN
	// maybe that has to do with the USB implementation max packet size?
	
	
	void MIDIDevice::sysex_byte(uint8_t b)
	{
		if (handleSysExPartial && msg_sysex_len >= SYSEX_MAX_LEN)
		{
			// when buffer is full, send another chunk to partial handler.
			(*handleSysExPartial)(msg_sysex, msg_sysex_len, 0);
			msg_sysex_len = 0;
		}
		if (msg_sysex_len < SYSEX_MAX_LEN)
		{
			msg_sysex[msg_sysex_len++] = b;
		}
	}



#endif	 	// Pauls parser
