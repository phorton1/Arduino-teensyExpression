
    #endif

    
    
    #if 0 && WITH_SYSTEM        
        
        // LEDFancyStart();
        for (int x=0; x<100; x++)
        {
            float bright = ((float)x)/100.00 * 70;
            setLEDBrightness((int)bright);
            showLEDs();    
            
            #if WITH_CHEAP_TFT
                float use_x = (x * 360.00) / 101;
                int use_w = 5;
                mylcd.Fill_Rect(use_x+50,180,use_w,30, TFT_BLUE);
            #endif
            
            #if WITH_TFT
                int use_x = x * 260 / 101;
                int use_w = 3;
                tft.fillRect(use_x+30, 120, use_w, 30, ILI9341_BLUE);
            #endif
            
            delay(15);
        }
        
        delay(200);

        #if WITH_CHEAP_TFT
            mylcd.Fill_Rect(40,110,400,100,0);
            mylcd.Print_String("Ready", 180, 110);
            mylcd.setDefaultFont();
            mylcd.Set_Text_Size(2);
        #endif
        
        #if WITH_TFT
            tft.fillRect(0, 60, 320, 180, ILI9341_BLACK);
            tft.setCursor(110, 60);
            tft.println("Ready");
        #endif
        
        #if WITH_SYSTEM
            clearLEDs();
            showLEDs();
        #endif
        
    #endif

    #if WITH_MIDI_HOST && WITH_TFT
        delay(1200);
        tft.fillScreen(ILI9341_BLACK);
        tft.setFont(Arial_10);
        tft.setCursor(0,0);
    #endif        

    #if WITH_SYSTEM




#if WITH_EXPRESSION_PEDAL

    #define CALIB_MARGIN 10
        // added to top and bottom to give
        // "safe" 0 and 127 values
    
    void calibrate()
    {
        int raw_value = analogRead(pedals[calibrate_pedal].pin);
        if (raw_value-CALIB_MARGIN > pedals[calibrate_pedal].calib_max)
        {
            // display(0,"max:%d",raw_value);
            pedals[calibrate_pedal].calib_max = raw_value - CALIB_MARGIN;
            if (pedals[calibrate_pedal].calib_max < 0)
                pedals[calibrate_pedal].calib_max =0;
        }
        if (raw_value + CALIB_MARGIN < pedals[calibrate_pedal].calib_min)
        {
            // display(0,"min:%d",raw_value);
            pedals[calibrate_pedal].calib_min = raw_value + CALIB_MARGIN;
            if (pedals[calibrate_pedal].calib_min > 1023)
                pedals[calibrate_pedal].calib_min = 1023;
        }
        if (blink_time > (blink_state ? CALIBRATE_BLINK_ON_TIME : CALIBRATE_BLINK_OFF_TIME))
        {
            blink_time = 0;
            blink_state = !blink_state;
            digitalWrite(PIN_ONBOARD_LED,blink_state);
        }
    }
    
    void startCalibrate(int pedal)
    {
        #if WITH_SERIAL
            display(0,"CALIBRATE %s",pedals[pedal].name);
        #endif
        calibrate_pedal = pedal;
        calibrate_time = 0;
        pedals[pedal].calib_min = 1023;
        pedals[pedal].calib_max = 0;
    }
    
    
    #define HYSTERISIS   30
    
    int getValue(int pedal)
    {
        static int direction = 0;
        static elapsedMillis settle_time = 0;
        
        int raw_value = analogRead(pedals[0].pin);
        int pedal_raw = pedals[0].raw_value;
        
        if (!direction)
        {
            if (raw_value > pedal_raw + HYSTERISIS)
            {
                direction = 1;
                pedal_raw = raw_value;
                settle_time = 0;
            }
            else if (raw_value < pedal_raw - HYSTERISIS)
            {
                direction = -1;
                pedal_raw = raw_value;
                settle_time = 0;
            }
        }
        else if (settle_time > 50)
        {
            settle_time = 0;
            direction = 0;
        }
        else if (direction > 0 && raw_value > pedal_raw)
        {
            pedal_raw = raw_value;
            settle_time = 0;
        }
        else if (direction < 0 && raw_value < pedal_raw)
        {
            pedal_raw = raw_value;
            settle_time = 0;
        }
        pedals[pedal].raw_value = pedal_raw;
        
        int value = map(pedal_raw,pedals[pedal].calib_min,pedals[pedal].calib_max,0,127);
        if (value > 127) value=127;
        if (value < 0) value=0;
        return value;
    }
    
#endif


    
    #if WITH_EXPRESSION_PEDAL
        if (monitor.rpiReady())
        {
            static int last_value = 0;
            int value = getValue(0);
            if (value != last_value)
            {
                last_value = value;
                display(0,"value=%d",value);
                
                char buf[5];
                buf[0] = pedals[0].cable;       // cable
                buf[1] = pedals[0].channel;     // channel
                buf[2] = 0x0B;                  // msg
                buf[3] = pedals[0].cc_num;      // param1
                buf[4] = value;
                Serial1.write(buf,5);
                
                #if WITH_MIDI
                    usbMIDI.sendControlChange(      // sends 0xB0 message
                        pedals[0].cc_num,           // to given cc_num
                        value,          
                        pedals[0].channel,          // to given channel
                        pedals[0].cable);           // on given cable
                #endif
            }
        }
    #endif
    


// leds.show() with 30 takes about 2.2 ms
// initial design for touch screen ... LCD uses 

#include <myDebug.h>
#include "expSystem.h"


#include "myLeds.h"
#include "rawButtonArray.h"


void inoHandleButtonEvent(void *obj, int row, int col, int event);
    // forward
rawButtonArray buttons(0,inoHandleButtonEvent);


//----------------------------------------------------------------------
// DETAILS
//----------------------------------------------------------------------
// PINS FOR ALL              LCD PIN
//
//     2    TOUCH_IRQ           2     Can use any digital pin
//     3    BUTTON_OUT_LATCH
//     4    BUTTON_OUT_CLOCK
//     5    LEDS_OUT                  1, 5, -8, -10, (31)
//     6    BUTTON_OUT_DATA
//     7    BUTTON_IN_LOAD
//     8    TOUCH_CS           11     Can use any digital pin 
//     9    LCD_DC              5
//    10    LCD_CS              3
//    11    LCD_SDI (MOSI)      6
//          TOUCH_DIN          12
//    12    LCD_SDO (MISO)      9
//          TOUCH_DO           13
//    13    LCD_SCK             7
//          TOUCH_CLK          10
//    14    BUTTON_DIN                A0
//    15    BUTTON_IN_CLOCK_ENABLE    A1
//    16    BUTTON_IN_CLOCK           A2
//    17    BUTTON_IN_DATA            A3
//   -18    LIQUID_SDA0               A4     
//   -19    LIQUID_SCL0               A5
//    20    PIN_EXPR1                 A6
//    21    PIN_EXPR2                 A7
//    22    PIN_EXPR1                 A8
//    23    PIN_EXPR2                 A9





//-----------------------------------------------------------
// setup
//-----------------------------------------------------------

void setup()
{
    Serial.begin(115200);
    delay(1200);
    display(0,"teensyExpression 1.2 started ..",0);
    
    initLEDs();

    #if 1   // FANCY START
    
        for (int row=0; row<NUM_BUTTON_ROWS; row++)
        {
            for (int col=0; col<NUM_BUTTON_COLS; col++)
            {
                float c = col;
                float r = row;
                
                float red = (c/4) * 255.0;
                float blue = ((4-c)/4) * 255.0;
                float green = (r/4) * 255.0;
                
                unsigned rr = red;
                unsigned gg = green;
                unsigned bb = blue;
                
                setLED(row,col,(rr << 16) + (gg << 8) + bb);
            }
        }
        
        for (int b=0; b<70; b++)
        {
            setLEDBrightness(b);
            delay(81-b);
        }
        delay(500);
        for (int b=0; b<15; b++)
        {
            setLEDBrightness(50);
            delay(20);
            setLEDBrightness(0);
            delay(80);
        }
        setLEDBrightness(80);
        delay(800);
        for (int row=0; row<NUM_BUTTON_ROWS; row++)
        {
            for (int col=0; col<NUM_BUTTON_COLS; col++)
            {
                setLED(row,col,0);
            }
        }
        showLEDs();
    #endif
    
    for (int col=0; col<NUM_BUTTON_COLS; col++)
    {
        buttons.setButtonEventMask(0,col,BUTTON_EVENT_PRESS | BUTTON_EVENT_CLICK);
        buttons.setButtonEventMask(1,col,BUTTON_EVENT_PRESS | BUTTON_EVENT_CLICK);
        buttons.setButtonEventMask(2,col,BUTTON_EVENT_PRESS | BUTTON_EVENT_CLICK);
        buttons.setButtonEventMask(3,col,BUTTON_EVENT_PRESS | BUTTON_EVENT_CLICK);
        buttons.setButtonEventMask(4,col,BUTTON_EVENT_PRESS | BUTTON_EVENT_RELEASE);
    }

    buttons.setButtonEventMask(0,4,BUTTON_EVENT_PRESS | BUTTON_EVENT_CLICK | BUTTON_EVENT_LONG_CLICK);
    buttons.setButtonEventMask(4,4,BUTTON_EVENT_PRESS | BUTTON_EVENT_RELEASE | BUTTON_EVENT_LONG_CLICK);
    
    buttons.begin();

    
}


//-----------------------------------------
// loop
//-----------------------------------------

void loop()
{
    // showLEDs();
}



int mode = 0;

//--------------------------------------------------------
// Button event handler
//--------------------------------------------------------

void inoHandleButtonEvent(void *obj, int row, int col, int event)
{
    display(0,"row(%d) col(%d) event(%s)",row,col,rawButtonArray::buttonEventName(event));
    
    if (event == BUTTON_EVENT_PRESS)
        setLED(row,col,WHITE);
        
    if (row < 3)
    {
        if (event == BUTTON_EVENT_LONG_CLICK)
        {
            setLED(row,col,PINK);
            mode = 1;
        }
        else if (event == BUTTON_EVENT_CLICK)
        {
            for (int r=0; r<3; r++)
                for (int c=0; c<NUM_BUTTON_COLS; c++)
                    if ((r!=row) || (c!=col))
                        setLED(r,c,0);
            setLED(row,col,BLUE);
        }
        
    }
        
    if (row == 3)
    {
        if (event == BUTTON_EVENT_CLICK)
        {
            static bool toggle[5] = {0,0,0,0,0};
            toggle[col] = !toggle[col];
            setLED(row,col,toggle[col]?GREEN:0);
        }
    }
    if (row == 4)
    {
        static bool touched[5] = {0,0,0,0,0};
        static bool was_cleared = false;
        if (event == BUTTON_EVENT_LONG_CLICK)
        {
            was_cleared = true;
            for (int j=0; j<NUM_BUTTON_COLS; j++)
            {
                setLED(row,j,0);
                touched[j] = false;
            }
        }
        else if (event == BUTTON_EVENT_RELEASE)
        {
            if (was_cleared)
                was_cleared = false;
            else
            {
                for (int j=0; j<NUM_BUTTON_COLS; j++)
                    if (j != col)
                        if (touched[j])
                            setLED(row,j,YELLOW);
                setLED(row,col,RED);
                touched[col] = true;
            }
        }
    }
    
    showLEDs();
}

    



