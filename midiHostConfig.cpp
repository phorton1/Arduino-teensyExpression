#include <myDebug.h>
#include "midiHostConfig.h"
#include "defines.h"
#include "myTFT.h"
#include "myLeds.h"
#include "buttons.h"

#define SHOW_MIDI_EVENTS   1


#if WITH_MIDI_HOST
	#define MIDI_PASS_THRU  1
	#include "myMidiHost.h"
#endif


#define BUTTON_ONE   20
#define BUTTON_TWO   21


bool showOnTFT = 0;
void showBufferedDisplay();
void printBuffered(const char *format, ...);



//------------------------------------------------------------
// life cycle
//------------------------------------------------------------

midiHostConfig::midiHostConfig() 
{
    draw_needed = 0;
    redraw_needed = 0;
}


// virtual
void midiHostConfig::begin()
{
	expConfig::begin();	
    draw_needed = 1;

    theButtons.setButtonEventMask(BUTTON_ONE, BUTTON_EVENT_CLICK);
    theButtons.setButtonEventMask(BUTTON_TWO, BUTTON_EVENT_CLICK);
	setLED(BUTTON_ONE,LED_BLUE);
	setLED(BUTTON_TWO,LED_BLUE);
	
	showLEDs();
}




//------------------------------------------------------------
// events
//------------------------------------------------------------

uint32_t send_it = 0;



// virtual
void midiHostConfig::onButtonEvent(int row, int col, int event)
{
	int num = row * NUM_BUTTON_COLS + col;

	if (num == BUTTON_ONE)		// sysex test
	{
		// SYSEX DEVICE ID REQUEST
		// Send:  F0 7E 7F 06 01 F7
		// Expected:           F0 7E 10 06 02 00 01 6E 00 01 00 01 02 21 01 00 F7
		// Got (same for both dongles) from HOST :
		//		SysEx Message: F0 7E 00 06 02 00 01 6E 00 01 00 02 01 55 01 00 F7  (end)
		//		SysEx Message: F0 7E 10
		//                     F0 7E 10 06 02 00 06 02 00 01 6E 00 01 6E 00 01 00 01 01 00 01 02 21 01 02 21 01 00 F7  (end)
		//		SysEx Message: 00 F7  (end)
		// Got from iPad:      F0 7E 10 06 02 00 01 6E 00 01 00 01 02 21 01 00 F7
		//      == expected


		#define REQUEST_LEN  6
		uint8_t data[REQUEST_LEN] = {0xF0, 0x7E, 0x7F, 0x06, 0x01, 0xF7};

		showOnTFT = 1;
			// echo the results
		
		#if WITH_MIDI_HOST
			if (midi_host_on)
			{
				display(0,"sending request(%d) to MIDI_HOST",REQUEST_LEN);
				midi1.sendSysEx(REQUEST_LEN,data,true);
			}
			else
		#endif
		{
			display(0,"sending request(%d) as midi device",REQUEST_LEN);
			usbMIDI.sendSysEx(REQUEST_LEN,data,true); 	
		}

		setLED(num,LED_BLUE);
		showLEDs();
	}
	
	else if (num == BUTTON_TWO)		// trying to figure out senstitivy
	{
		display(0,"Sending control change B7 1F 3C as device",0);

		#if 0
			uint32_t msg = 0x3c1Fb70b;
			// doesn't pay any attention to MIDI_NUM_CABLES
			usb_midi_write_packed(msg);		// write as device
			usb_midi_flush_output();
		#else
			// Does pay attention to cables
			usbMIDI.sendControlChange(0x1F, 0x3C, 8, 0);
				// should send B7 1F 3C
		#endif

		// send_it = 255;
			// a scheme to send out 255 messages

		setLED(num,LED_BLUE);
		showLEDs();
	}
}


#if 0		// Pauls parser

	// ok, so the question is how much of this do I keep
	// or re-implementl, or should I switch back to Paul's code?
	
	// Right now, at a uint32_t per message I'm pretty fast,
	// but the USB's could be hooked up even tighter as the
	// endpoint packet sizes allowed ... to echo whole buffers
	// from the hosted device to the device-device.
	
	// In practice, I am guessing that I rarely get a packet
	// that contains two distinct events (i.e. note-on) though
	// it could happen like when strumming.
	
	// I need to try to get it as fast as possible to *maybe* act
	// as the host for the FTP, but there is no good way to measure
	// it versus plugging directly into the iPad ...
	
	// hmm .. a recording app on the iPad could record the guitar
	// signal and compare it to the sound generated by the synth.
	
	

	
	bool MIDIDevice::read(uint8_t channel)
	{
		uint32_t n, head, tail, avail, ch, type1, type2, b1;
	
		head = rx_head;
		tail = rx_tail;
		if (head == tail) return false;
		if (++tail >= RX_QUEUE_SIZE) tail = 0;
		n = rx_queue[tail];
		rx_tail = tail;
		if (!rx_packet_queued && rxpipe) {
				avail = (head < tail) ? tail - head - 1 : RX_QUEUE_SIZE - 1 - head + tail;
			if (avail >= (uint32_t)(rx_size>>2)) {
				__disable_irq();
				queue_Data_Transfer(rxpipe, rx_buffer, rx_size, this);
				__enable_irq();
			}
		}
		println("read: ", n, HEX);
		
		// 0x3C1FB70B    =   B7 1F  3C    
	
		type1 = n & 15;					// 0x0B = low order nibble of MSB = the midi "message_type"
		type2 = (n >> 12) & 15;         // 0x0B = high order nibble of 2nd MSB = the midi message "command"
		b1 = (n >> 8) & 0xFF;           // 0xB7 = the full midi message command (with channel)
		ch = (b1 & 15) + 1;             // 8 == the one based channel number
		
		msg_cable = (n >> 4) & 15;      // 0x00 = high order nibble of MSB = midi "cable" number
			// we receive cables 0 and 1 from the FTP
			// midiOx only accepts on cable 0 (i.e I am not using teensy USB mode MIDI4, etc)
			
		// midi commands 0x8 thru 0xE (0x8n thru 0xEn) have a channel built in to the 0th byte
		// and are not realtime or "common"
		
		
		if (type1 >= 0x08 && type1 <= 0x0E)		// NON-REALTIME CHANNEL MESSAGES
		{
			if (channel && channel != ch)
			{
				// ignore other channels when user wants single channel read
				return false;
			}
			
			// I wonder why he assiduously checks both numbers
			// Do devices often not send correct midi messages
			// where they disagree?
			
			if (type1 == 0x08 && type2 == 0x08)
			{
				msg_type = 0x80;		// 0x80 = Note off
				if (handleNoteOff) {
					(*handleNoteOff)(ch, (n >> 16), (n >> 24));
				}
			}
			else if (type1 == 0x09 && type2 == 0x09)
			{
				if ((n >> 24) > 0)
				{
					msg_type = 0x90;	// 0x90 = Note on
					if (handleNoteOn)
					{
						(*handleNoteOn)(ch, (n >> 16), (n >> 24));
					}
				}
				else
				{
					msg_type = 0x80;	// 0x80 = Note off
					if (handleNoteOff)
					{
						(*handleNoteOff)(ch, (n >> 16), (n >> 24));
					}
				}
			} else	if (type1 == 0x0A && type2 == 0x0A)
			{
				msg_type = 0xA0;		// 0xA0 = AfterTouchPoly
				if (handleVelocityChange)
				{
					(*handleVelocityChange)(ch, (n >> 16), (n >> 24));
				}
			}
			else if (type1 == 0x0B && type2 == 0x0B)
			{
				msg_type = 0xB0;		// 0xB0 = Control Change
				if (handleControlChange)
				{
					(*handleControlChange)(ch, (n >> 16), (n >> 24));
				}
			}
			else if (type1 == 0x0C && type2 == 0x0C)
			{
				msg_type = 0xC0;		// 0xC0 = Program Change
				if (handleProgramChange)
				{
					(*handleProgramChange)(ch, (n >> 16));
				}
			}
			else if (type1 == 0x0D && type2 == 0x0D)
			{
				msg_type = 0xD0;		// 0xD0 = After Touch
				if (handleAfterTouch)
				{
					(*handleAfterTouch)(ch, (n >> 16));
				}
			} else if (type1 == 0x0E && type2 == 0x0E)
			{
				msg_type = 0xE0;		// 0xE0 = Pitch Bend
				if (handlePitchChange)
				{
					int value = ((n >> 16) & 0x7F) | ((n >> 17) & 0x3F80);
					value -= 8192; // 0 to 16383 --> -8192 to +8191
					(*handlePitchChange)(ch, value);
				}
			}
			else
			{
				return false;
			}
			
		return_message:
		
			msg_channel = ch;
			msg_data1 = (n >> 16);
			msg_data2 = (n >> 24);
			return true;
		
		}	// CHANNEL SPECIFIC MESSAGES
		
		
		// CHANNEL SPECIFIC SYSTEM COMMON OR REALTIME MESSAGES
		
		if (type1 == 0x02 ||
			type1 == 0x03 ||
			(type1 == 0x05 && b1 >= 0xF1 && b1 != 0xF7))
		{
		system_common_or_realtime:
			
			switch (b1)
			{
				case 0xF1: // usbMIDI.TimeCodeQuarterFrame
					if (handleTimeCodeQuarterFrame)
					{
						(*handleTimeCodeQuarterFrame)(n >> 16);
					}
					break;
				case 0xF2: // usbMIDI.SongPosition
					if (handleSongPosition)
					{
						(*handleSongPosition)(((n >> 16) & 0x7F) | ((n >> 17) & 0x3F80));
					}
					break;
				case 0xF3: // usbMIDI.SongSelect
					if (handleSongSelect)
					{
						(*handleSongSelect)(n >> 16);
					}
					break;
				case 0xF6: // usbMIDI.TuneRequest
					if (handleTuneRequest)
					{
						(*handleTuneRequest)();
					}
					break;
				case 0xF8: // usbMIDI.Clock
					if (handleClock)
					{
						(*handleClock)();
					}
					else if (handleRealTimeSystem)
					{
						(*handleRealTimeSystem)(0xF8);
					}
					break;
				case 0xFA: // usbMIDI.Start
					if (handleStart)
					{
						(*handleStart)();
					}
					else if (handleRealTimeSystem)
					{
						(*handleRealTimeSystem)(0xFA);
					}
					break;
				case 0xFB: // usbMIDI.Continue
					if (handleContinue)
					{
						(*handleContinue)();
					}
					else if (handleRealTimeSystem)
					{
						(*handleRealTimeSystem)(0xFB);
					}
					break;
				case 0xFC: // usbMIDI.Stop
					if (handleStop)
					{
						(*handleStop)();
					}
					else if (handleRealTimeSystem)
					{
						(*handleRealTimeSystem)(0xFC);
					}
					break;
				case 0xFE: // usbMIDI.ActiveSensing
					if (handleActiveSensing)
					{
						(*handleActiveSensing)();
					}
					else if (handleRealTimeSystem)
					{
						(*handleRealTimeSystem)(0xFE);
					}
					break;
				case 0xFF: // usbMIDI.SystemReset
					if (handleSystemReset)
					{
						(*handleSystemReset)();
					}
					else if (handleRealTimeSystem)
					{
						(*handleRealTimeSystem)(0xFF);
					}
					break;
				default:
					return false; // unknown message, ignore it
			}
			msg_type = b1;
			goto return_message;
		}
		
		// SYSEX (continue) messge
		
		if (type1 == 0x04) {
			sysex_byte(n >> 8);
			sysex_byte(n >> 16);
			sysex_byte(n >> 24);
			return false;
		}
		
		// SYSEX (end) message
		// where the length is encoded in the type
		
		if (type1 >= 0x05 &&
			type1 <= 0x07)
		{
			sysex_byte(b1);
			
			// allow for buggy devices which use code 5 to transmit 1 byte at a time
			// https://forum.pjrc.com/threads/43450?p=164596&viewfull=1#post164596
			
			if (type1 == 0x05 && b1 != 0xF7) return false;
			if (type1 >= 0x06) sysex_byte(n >> 16);
			if (type1 == 0x07) sysex_byte(n >> 24);
			
			uint16_t len = msg_sysex_len;
			msg_data1 = len;
			msg_data2 = len >> 8;
			msg_sysex_len = 0;
			msg_type = 0xF0;			// 0xF0 = SystemExclusive
			
			if (handleSysExPartial)
			{
				(*handleSysExPartial)(msg_sysex, len, 1);
			}
			else if (handleSysExComplete)
			{
				(*handleSysExComplete)(msg_sysex, len);
			}
			return true;
		}
		
		// SYSEX (start) message,
		// except 0xF8 which is a realtime message ...
		
		if (type1 == 0x0F)
		{
			if (b1 >= 0xF8)
			{
				goto system_common_or_realtime;
			}
			
			// this is the code that allows sysex messages to include
			// subsequent F0's in them, which midiOx doesn't deal with
			
			if (b1 == 0xF0 || msg_sysex_len > 0)
			{
				// Is this really needed?  Mac OS-X does this, but do any devices?
				sysex_byte(b1);
			}
		}
		return false;
	}
	
	
	// weird that it's artificially limited to 290 by SYSEX_MAX_LEN
	// maybe that has to do with the USB implementation max packet size?
	
	
	void MIDIDevice::sysex_byte(uint8_t b)
	{
		if (handleSysExPartial && msg_sysex_len >= SYSEX_MAX_LEN)
		{
			// when buffer is full, send another chunk to partial handler.
			(*handleSysExPartial)(msg_sysex, msg_sysex_len, 0);
			msg_sysex_len = 0;
		}
		if (msg_sysex_len < SYSEX_MAX_LEN)
		{
			msg_sysex[msg_sysex_len++] = b;
		}
	}



#endif	 	// Pauls parser


//------------------------------------------------------------
// updateUI (draw)
//------------------------------------------------------------
// also used to send repetitive midi events every so often

elapsedMillis send_timer = 0;

// virtual
void midiHostConfig::updateUI()	// draw
{
	if (send_it && send_timer > 200)
	{
		send_timer = 0;

		// I found that i get a response if I write
		// b7 1f 07  followed by b7 3f 03, so this
		// loop tries each with 0..15
		
		uint32_t msg1 = 0x001Fb70b | ((send_it&0xf0)<<20);
		uint32_t msg2 = 0x003Fb70b | ((send_it&0x0f)<<24);
		
		display(0,"Writing msg1 0x1f %02x %02x",(msg1 >> 24),(msg1 >> 16) & 0xff,(msg1 >> 8) & 0xff);
		midi1.write_packed(msg1);
		
		delay(100);
		display(0,"Writing msg2 0x1f %02x %02x",(msg2 >> 24),(msg2 >> 16) & 0xff,(msg2 >> 8) & 0xff);
		midi1.write_packed(msg2);

		send_it--;
	}

	if (draw_needed)
	{
		#if 0
			mylcd.Fill_Screen(0);
			mylcd.setFont(Arial_16_Bold);
			mylcd.Set_Text_Cursor(10,10);
			mylcd.Set_Text_colour(TFT_YELLOW);
			mylcd.print(getCurConfig()->name());
			mylcd.Set_Draw_color(TFT_YELLOW);
			mylcd.Draw_Line(0,36,TFT_WIDTH,36);
		#endif

		draw_needed = false;
		mylcd.setFont(Arial_20);
		mylcd.Set_Text_Cursor(20,50);
		mylcd.Set_Text_colour(TFT_WHITE);
		
		#if WITH_MIDI_HOST
			mylcd.print("MIDI_HOST ");
			mylcd.println(midi_host_on ? "ON" : " is OFF!! it must be on!!");
		#else
			mylcd.println("WITH_MIDI_HOST is not defined!!");
		#endif
	}
	
	#if OLD_EFFING_WAY
		// don't turn this on! it is here to remind me of how
		// I used to do it.
		myusb.Task();
		midi1.read();
		usbMIDI.read();
	#endif
	
	showBufferedDisplay();
}


//---------------------------------------------------
// Events
//---------------------------------------------------

// virtual
void midiHostConfig::onMidiEvent(uint32_t msg)
{
	// display(0,"onMidiEvent(%08x)",msg);
	
	#if SHOW_MIDI_EVENTS
		printBuffered("device <-- %08X",msg);
	#endif
	
	#if WITH_MIDI_HOST
		#if MIDI_PASS_THRU
			midi1.write_packed(msg);
		#endif
	#endif
}



typedef union
{
	uint32_t msg;
	unsigned char b[4];
}   midiMsg_t;


#if WITH_MIDI_HOST
	// virtual
	void midiHostConfig::onMidiHostEvent(uint32_t msg)
	{
		#if 0
			midiMsg_t u;
			u.msg = msg;
			if (u.b[1] != 0xFE)
				display(0,"onMidiHostEvent(%08x) %02x %02x %02x %02x",msg,u.b[0],u.b[1],u.b[2],u.b[3]);
		#endif
		
		// 0x3C1FB70B    =   B7 1F  3C    
		
		#if SHOW_MIDI_EVENTS
			// if (0 && (msg & 0xFF00) == 0xFE00)	 // filter out active sensing
			// 	return;
			// #if 0
			// 	if (msg & 0xf0)					// filter out duplicate events from cable 1
			// 		return;
			// #endif
				
				// I *think* I only need one of the two cables,
				// not sure exactly which is which.
				
			printBuffered("host  <-- %08X",msg);
		#endif
		
		#if 0 && MIDI_PASS_THRU && !USE_MIDI_HOST_IRQ
			
			// the !USE_MIDI_HOST_IRQ is not needed as this
			// method will not be called in case USE_MIDI_HOST_IRQ=1
			// but I included it for sanity
			
			usb_midi_write_packed(msg);		// write as device
			usb_midi_flush_output();
		#endif		
	}
#endif




//---------------------------------------------------
// buffered display
//---------------------------------------------------
// CONSOLE.pm serial port buffer overflows if we just send all
// this text from the interrutps, so we buffer it and send it
// out one line at a time, in updateUI() based on a ms timer.

#define MAX_STRING 256
#define MAX_DISPLAY_BUFFER 32768

char temp_buffer[MAX_STRING];
char display_buffer[MAX_DISPLAY_BUFFER];
volatile int buf_write = 0;
volatile int buf_read = 0;


elapsedMillis buffer_timer = 0;


void showBufferedDisplay()
{
	if (buf_read != buf_write && buffer_timer > 8)
	{
		static char work_buffer[MAX_STRING];
		
		int len = 0;
		char *op = work_buffer;
		char *ip = &display_buffer[buf_read];
		
		while (*ip && len<MAX_STRING)
		{
			len ++;
			buf_read++;
			*op++ = *ip ++;
			
			if (buf_read == MAX_DISPLAY_BUFFER)
			{
				buf_read = 0;
				ip = display_buffer;
			}
			if (buf_read == buf_write)
			{
				my_error("read buffer overflow at %d,%d?!?!",buf_read,buf_write);
				buf_read = buf_write = 0;
				return;
			}
		}
		
		*op++ = 0;
		buf_read++;
		if (buf_read == MAX_DISPLAY_BUFFER)
			buf_read = 0;


		// Serial.print(ptr->host ? "\033[95m" : "\033[94m");
		Serial.println(work_buffer);
		
		if (showOnTFT)
		{
			mylcd.setFont(Arial_12);
			mylcd.println(work_buffer);			
		}
		buffer_timer = 0;
	}
}


void addBufferedString(char *s)
{
	// int len = strlen(s);
	
	char *op = &display_buffer[buf_write];
	while (*s)
	{
		*op++ = *s++;
		buf_write++;
		if (buf_write == MAX_DISPLAY_BUFFER)
		{
			buf_write = 0;
			display(0,"WRAP",0);
			op = display_buffer;
		}
		if (buf_write == buf_read)
		{
			my_error("write buffer overflow",0);
			buf_read = buf_write = 0;
			return;
		}
	}
	*op++ = 0;
	buf_write++;
	if (buf_write == MAX_DISPLAY_BUFFER)
		buf_write = 0;
	if (buf_write == buf_read)
	{
		my_error("write buffer overflow2",0);
		buf_read = buf_write = 0;
		return;
	}
}


void printBuffered(const char *format, ...)
{
	va_list var;
	va_start(var, format);
	if (strlen(format) >= MAX_STRING/2)
	{
		my_error("error - MAX_STRING overflow",0);
		return;
	}
	vsprintf(temp_buffer,format,var);
	addBufferedString(temp_buffer);
}


void printBytes(const char *before, const byte *data, unsigned int size, const char *after)
{
	int full_len = 1 + size * 3 +
		(before ? strlen(before) : 0) +
		(after ? strlen(after) : 0);
		
	if (full_len >= MAX_STRING)
	{
		my_error("error - printBytes buffer overflow",0);
		return;
	}
	
	char *p = temp_buffer;
	if (before)
	{
		strcpy(p,before);
		p += strlen(before);
	}
	
	while (size > 0)
	{
		size--;
		byte b = *data++;
		sprintf(p,"%02X ",b);
		p += 3;
	}

	if (after)
	{
		strcpy(p,after);
	}
	addBufferedString(temp_buffer);
}
	


