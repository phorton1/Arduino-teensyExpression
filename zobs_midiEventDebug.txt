	
//=====================================================
// NO LONGER USED
//=====================================================

#if 0		

void showTimeCodeQuarterFrame(bool host, byte data)
{
	static char SMPTE[8]={'0','0','0','0','0','0','0','0'};
	static byte fps=0;
	
	byte index = data >> 4;
	byte number = data & 15;
	if (index == 7)
	{
		fps = (number >> 1) & 3;
		number = number & 1;
	}

	if (index < 8 || number < 10)
	{
		SMPTE[index] = number + '0';
		
		printBuffered(host,"TimeCode: %d%d:%d%d:%d%d.%d%d %s",
			SMPTE[7],
			SMPTE[6],
			SMPTE[5],
			SMPTE[4],
			SMPTE[3],
			SMPTE[2],
			SMPTE[1],  // perhaps add 2 to compensate for MIDI latency?
			SMPTE[0],
			fps == 0 ? " 24 fps" :
			fps == 1 ? " 25 fps" :
			fps == 2 ? " 29.97 fps" :
			fps == 3 ? " 30 fps" :
			"unknown fps");
	}
	else
	{
		printBuffered(host,"TimeCode: invalid data = %04x",data);
	}
}	



//-----------------------------------------------
// device midi event handlers
//-----------------------------------------------



void deviceNoteOn(byte channel, byte note, byte velocity)
	{ printBuffered(0,"Note On, ch=%d note=%d velocity=%d",channel,note,velocity); }
void deviceNoteOff(byte channel, byte note, byte velocity)
	{ printBuffered(0,"Note Off, ch=%d note=%d velocity=%d",channel,note,velocity); }
void deviceAfterTouchPoly(byte channel, byte note, byte velocity)
	{ printBuffered(0,"AfterTochPoly, ch=%d note=%d velocity=%d",channel,note,velocity); }
void deviceControlChange(byte channel, byte control, byte value)
{
	printBuffered(0,"Control Change, ch=%d control=%d value=%d",channel,control,value);
	#if PASS_THRU
		midi1.sendControlChange(channel, control, value);
	#endif	
}
void deviceProgramChange(byte channel, byte program)
	{ printBuffered(0,"Program Change, ch=%d program=%d",channel,program); }
void deviceAfterTouchChannel(byte channel, byte pressure)
	{ printBuffered(0,"myAfterTouchChannel, ch=%d pressure=%d",channel,pressure); }
void devicePitchChange(byte channel, int pitch)
	{ printBuffered(0,"Pitch Change, ch=%d, pitch=%d",channel,pitch); }

void deviceSystemExclusiveChunk(const byte *data, uint16_t length, bool last)
{
	printBytes(0,"SysEx Message: ", data, length, last ? " (end)" : " (to be continued)");
	#if PASS_THRU
		midi1.sendSysEx(length,data,last); 	// true=hasTerm  default cable=0
	#endif
}
void deviceSystemExclusive(byte *data, unsigned int length)
{
	printBytes(0,"SysEx Message: ", data, length, 0);
	#if PASS_THRU
		midi1.sendSysEx(length,data,true); 	// true=hasTerm  default cable=0
	#endif
}

void deviceSongPosition(uint16_t beats)
	{ printBuffered(0,"Song Position, beat=%d",beats); }
void deviceSongSelect(byte songNumber)
	{ printBuffered(0,"Song Select, song=%d",songNumber); }
void deviceRealTimeSystem(uint8_t realtimebyte) 
	{ printBuffered(0,"Real Time Message, code=0x%02X",realtimebyte); }
	
void deviceTuneRequest()		{ printBuffered(0,"Tune Request"); }
void deviceClock()    			{ printBuffered(0,"Clock"); }
void deviceStart()				{ printBuffered(0,"Start"); }
void deviceContinue()			{ printBuffered(0,"Continue"); }
void deviceStop()   			{ printBuffered(0,"Stop"); }
void deviceActiveSensing()
{
	/* printBuffered(0, "Actvice Sensing"); */
	#if PASS_THRU
		usbMIDI.sendRealTime(0xFE);
	#endif
	
}
void deviceSystemReset()    	{ printBuffered(0,"System Reset"); }

void deviceTimeCodeQuarterFrame(byte data)
	{ showTimeCodeQuarterFrame(0, data); }



//-----------------------------------------------
// host midi event handlers
//-----------------------------------------------

#if WITH_MIDI_HOST

	// When a USB device with multiple virtual cables is used,
	// midi1.getCable() can be used to read which of the virtual
	// MIDI cables received this message.

	// This 3-input System Exclusive function is more complex, but allows you to
	// process very large messages which do not fully fit within the midi1's
	// internal buffer.  Large messages are given to you in chunks, with the
	// 3rd parameter to tell you which is the last chunk.  This function is
	// a Teensy extension, not available in the Arduino MIDI library.

	// This simpler 2-input System Exclusive function can only receive messages
	// up to the size of the internal buffer.  Larger messages are truncated, with
	// no way to receive the data which did not fit in the buffer.  If both types
	// of SysEx functions are set, the 3-input version will be called by midi1.
	
	void hostNoteOn(byte channel, byte note, byte velocity)
		{ printBuffered(1,"Note On, ch=%d note=%d velocity=%d",channel,note,velocity); }
	void hostNoteOff(byte channel, byte note, byte velocity)
		{ printBuffered(1,"Note Off, ch=%d note=%d velocity=%d",channel,note,velocity); }
	void hostAfterTouchPoly(byte channel, byte note, byte velocity)
		{ printBuffered(1,"AfterTochPoly, ch=%d note=%d velocity=%d",channel,note,velocity); }
	void hostControlChange(byte channel, byte control, byte value)
	{
		printBuffered(1,"Control Change, ch=%d control=%d value=%d",channel,control,value);
		#if PASS_THRU
			
			byte type = 0xB0;
			byte cable = 0;
			
			usb_midi_write_packed((type << 8) | (type >> 4) | ((cable & 0x0F) << 4)
			  | (((channel - 1) & 0x0F) << 8) | ((control & 0x7F) << 16)
			  | ((value & 0x7F) << 24));

			usb_midi_flush_output();
			
			// usbMIDI.sendControlChange(channel, control, value);
		#endif	
	}
	void hostProgramChange(byte channel, byte program)
		{ printBuffered(1,"Program Change, ch=%d program=%d",channel,program); }
	void hostAfterTouchChannel(byte channel, byte pressure)
		{ printBuffered(1,"myAfterTouchChannel, ch=%d pressure=%d",channel,pressure); }
	void hostPitchChange(byte channel, int pitch)
		{
			display(0,"pitch changed %d,%d",channel,pitch);
			printBuffered(1,"Pitch Change, ch=%d, pitch=%d",channel,pitch);
		}

	void hostSystemExclusiveChunk(const byte *data, uint16_t length, bool last)
	{
		printBytes(1,"SysEx Message: ", data, length, last ? " (end)" : " (to be continued)");
		#if PASS_THRU
			if (length > 3 &&
				data[3] == 0xF0 )
				usbMIDI.sendSysEx(length-3,&data[3],last); 	// true=hasTerm  default cable=0
			else
				usbMIDI.sendSysEx(length,data,last); 	// true=hasTerm  default cable=0
		#endif
	}
	void hostSystemExclusive(byte *data, unsigned int length)
	{
		printBytes(1,"SysEx Message: ", data, length, 0);
		#if PASS_THRU
			usbMIDI.sendSysEx(length,data,true); 	// true=hasTerm  default cable=0
		#endif
	}
	
	void hostSongPosition(uint16_t beats)
		{ printBuffered(1,"Song Position, beat=%d",beats); }
	void hostSongSelect(byte songNumber)
		{ printBuffered(1,"Song Select, song=%d",songNumber); }
	void hostRealTimeSystem(uint8_t realtimebyte) 
		{ printBuffered(1,"Real Time Message, code=0x%02X",realtimebyte); }
		
	void hostTuneRequest()		{ printBuffered(1,"Tune Request"); }
	void hostClock()    		{ printBuffered(1,"Clock"); }
	void hostStart()			{ printBuffered(1,"Start"); }
	void hostContinue()			{ printBuffered(1,"Continue"); }
	void hostStop()   			{ printBuffered(1,"Stop"); }
	void hostActiveSensing()
	{
		/* printBuffered(1, "Actvice Sensing"); */
		#if PASS_THRU
			usbMIDI.sendRealTime(0xFE);
		#endif
	}
	void hostSystemReset()    	{ printBuffered(1,"System Reset"); }
	
	void hostTimeCodeQuarterFrame(byte data)
		{ showTimeCodeQuarterFrame(1, data); }
	
#endif	// WITH_MIDI_HOST
	



//-----------------------------------------------
// register midi event handlers
//-----------------------------------------------
	

void registerAllHandlers(bool on)
{
	usbMIDI.setHandleNoteOn(				on ? deviceNoteOn : 0);
	usbMIDI.setHandleNoteOff(				on ? deviceNoteOff : 0);
	usbMIDI.setHandleAfterTouchPoly(		on ? deviceAfterTouchPoly : 0);
	usbMIDI.setHandleControlChange(			on ? deviceControlChange : 0);
	usbMIDI.setHandleProgramChange(			on ? deviceProgramChange : 0);
	usbMIDI.setHandleAfterTouchChannel(		on ? deviceAfterTouchChannel : 0);
	usbMIDI.setHandlePitchChange(			on ? devicePitchChange : 0);
	usbMIDI.setHandleSystemExclusive(		on ? deviceSystemExclusiveChunk : 0);
	usbMIDI.setHandleSystemExclusive(		on ? deviceSystemExclusive : 0);
	usbMIDI.setHandleTimeCodeQuarterFrame(	on ? deviceTimeCodeQuarterFrame : 0);
	usbMIDI.setHandleSongPosition(			on ? deviceSongPosition : 0);
	usbMIDI.setHandleSongSelect(			on ? deviceSongSelect : 0);
	usbMIDI.setHandleTuneRequest(			on ? deviceTuneRequest : 0);
	usbMIDI.setHandleClock(					on ? deviceClock : 0);
	usbMIDI.setHandleStart(					on ? deviceStart : 0);
	usbMIDI.setHandleContinue(				on ? deviceContinue : 0);
	usbMIDI.setHandleStop(					on ? deviceStop : 0);
	usbMIDI.setHandleActiveSensing(			on ? deviceActiveSensing : 0);
	usbMIDI.setHandleSystemReset(			on ? deviceSystemReset : 0);
	usbMIDI.setHandleRealTimeSystem(		on ? deviceRealTimeSystem : 0);

	#if WITH_MIDI_HOST
		// Only one of the System Exclusive handlers will actually be
		// used.  See the comments below for the difference between them.
		// This generic System Real Time handler is only used if the
		// more specific ones are not set.
	
		midi1.setHandleNoteOn(					on ? hostNoteOn : 0);
		midi1.setHandleNoteOff(					on ? hostNoteOff : 0);
		midi1.setHandleAfterTouchPoly(			on ? hostAfterTouchPoly : 0);
		midi1.setHandleControlChange(			on ? hostControlChange : 0);
		midi1.setHandleProgramChange(			on ? hostProgramChange : 0);
		midi1.setHandleAfterTouchChannel(		on ? hostAfterTouchChannel : 0);
		midi1.setHandlePitchChange(				on ? hostPitchChange : 0);
		midi1.setHandleSystemExclusive(			on ? hostSystemExclusiveChunk : 0);
		midi1.setHandleSystemExclusive(			on ? hostSystemExclusive : 0);
		midi1.setHandleTimeCodeQuarterFrame(	on ? hostTimeCodeQuarterFrame : 0);
		midi1.setHandleSongPosition(			on ? hostSongPosition : 0);
		midi1.setHandleSongSelect(				on ? hostSongSelect : 0);
		midi1.setHandleTuneRequest(				on ? hostTuneRequest : 0);
		midi1.setHandleClock(					on ? hostClock : 0);
		midi1.setHandleStart(					on ? hostStart : 0);
		midi1.setHandleContinue(				on ? hostContinue : 0);
		midi1.setHandleStop(					on ? hostStop : 0);
		midi1.setHandleActiveSensing(			on ? hostActiveSensing : 0);
		midi1.setHandleSystemReset(				on ? hostSystemReset : 0);
		midi1.setHandleRealTimeSystem(			on ? hostRealTimeSystem : 0);
	#endif
}


#endif 	// NO LONGER USED